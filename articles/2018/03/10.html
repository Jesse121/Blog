<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>《ECMAScript6标准入门》第三版--读书笔记 | 前端之路</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
    <meta name="description" content="专注前端开发，前端开发技术博客">
  
  
    <meta name="keywords" content="Web前端开发，Javascript，前端开发博客">
  
  
    <link rel="alternate" href="/blog/atom.xml" title="前端之路" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/blog/css/style.css">

  
    
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.min.css">

  
  
  
    
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">前端之路</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">路漫漫其修远兮，吾将上下而求索</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/blog/."><i class="fa fa-home"></i> 首页</a>
        
          <a class="main-nav-link" href="/blog/archives/"><i class="fa fa-archive"></i> 归档</a>
        
          <a class="main-nav-link" href="/blog/about/"><i class="fa fa-user"></i> 关于</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article
  id="post-notes/《ECMAScript6标准入门》第二版--读书笔记"
  class="h-entry article article-type-post"
  itemprop="blogPost"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div class="article-inner">
     
    <header class="article-header">
      
  
    <h1 class="p-name article-title" itemprop="headline name">
      《ECMAScript6标准入门》第三版--读书笔记
    </h1>
  


    </header>
    
    <div class="article-meta">
       <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2018-03-09T16:00:00.000Z" itemprop="datePublished">2018年03月10日</time>
</span> 
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/blog/categories/notes/">读书笔记</a>
  </div>
  <span class="article-views">
  <i class="fa fa-views"></i>
  <i id="busuanzi_container_page_pv">
      <i id="busuanzi_value_page_pv"></i>
  </i>
</span>
  
<a href="/blog/articles/2018/03/10.html#comments" class="article-comment-link">
  
    
    
    
    
    
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
       <p>2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。尽管在目前的工作中还没有使用 ES6，但是每项新技术出来总是忍不住想尝尝鲜，想知道 ES6 能为前端开发带来哪些变化？对自己的工作有哪些方面可以提升。刚好看到阮一峰的《ES6 标准入门》，便顺着这本书尝试着 ES6 的各种新特性。</p>
<span id="more"></span>

<p>ES6 的各种新特性的兼容性查询<a target="_blank" rel="noopener" href="http://kangax.github.io/compat-table/es6/">http://kangax.github.io/compat-table/es6/</a><br>尽管我们的浏览器还不一定完全支持 ES6 代码，我们可以使用 Babel 转码器,在这里我们使用命令行转码<strong>babel-cli</strong>，命令行<code>$ npm install --global babel-cli</code>安装 babel-cli</p>
<h3 id="第二章-let-和-const-命令"><a href="#第二章-let-和-const-命令" class="headerlink" title="第二章 let 和 const 命令"></a>第二章 let 和 const 命令</h3><h4 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h4><p>ES6 新增了 let 命令，用来声明变量。它的用法类似于 var ，但是所声明的变量，只在 let 命令所在的代码块内有效。let 不像 var 那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a; <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。<br>let 不允许在相同作用域内，重复声明同一个变量。let 实际上为 JavaScript 新增了块级作用域。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。</p>
<h4 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h4><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。<br>const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">MAX</span>); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">MAX</span> = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。 const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line">foo.<span class="property">prop</span>; <span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<p>ES6 规定 var 命令和 function 命令声明的全局变量，依旧是全局对象的属性；let 命令、 const 命令、 class 命令声明的全局变量，不属于全局对象的属性。<br>ES5 只有两种声明变量的方式，var 和 function 命令，ES6 有 6 种方式，var,function,let,const,class,import</p>
<h3 id="第三章-变量的解构赋值"><a href="#第三章-变量的解构赋值" class="headerlink" title="第三章 变量的解构赋值"></a>第三章 变量的解构赋值</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo; <span class="comment">// 1</span></span><br><span class="line">bar; <span class="comment">// 2</span></span><br><span class="line">baz; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>解构赋值允许指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[x, y = <span class="string">&quot;b&quot;</span>] = [<span class="string">&quot;a&quot;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line">[x, y = <span class="string">&quot;b&quot;</span>] = [<span class="string">&quot;a&quot;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意，ES6 内部使用严格相等运算符（ &#x3D;&#x3D;&#x3D; ），判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefined ，默认值是不会生效的。</p>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">foo; <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar; <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz; <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo; <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>

<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">[a, b]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//[3,7]</span></span><br></pre></td></tr></table></figure>

<h4 id="变量解构赋值用途"><a href="#变量解构赋值用途" class="headerlink" title="变量解构赋值用途"></a>变量解构赋值用途</h4><ol>
<li>交换变量的值<code>[x, y] = [y, x];</code></li>
<li>提取 JSON 数据<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">    id: <span class="number">42</span>,</span><br><span class="line">    <span class="keyword">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">    <span class="keyword">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line">let &#123; id, <span class="keyword">status</span>, <span class="keyword">data</span>: <span class="keyword">number</span> &#125; = jsonData;</span><br><span class="line">console.<span class="built_in">log</span>(id, <span class="keyword">status</span>, <span class="keyword">number</span>);// <span class="number">42</span>, <span class="string">&quot;OK&quot;</span>, [<span class="number">867</span>, <span class="number">5309</span>]</span><br></pre></td></tr></table></figure></li>
<li>函数参数的默认值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.<span class="property">ajax</span> = <span class="keyword">function</span> (<span class="params">url, &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">async</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">    beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span></span><br><span class="line"><span class="params">    cache = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">    complete = <span class="keyword">function</span> () &#123;&#125;,</span></span><br><span class="line"><span class="params">    crossDomain = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">    <span class="variable language_">global</span> = <span class="literal">true</span></span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="第四章-字符串的扩展"><a href="#第四章-字符串的扩展" class="headerlink" title="第四章 字符串的扩展"></a>第四章 字符串的扩展</h3><h4 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h4><p>es6 为字符串添加了遍历器接口，使得字符串可以由 for…of 循环遍历</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&quot;foo&quot;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(codePoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>includes()：返回布尔值，表示是否找到了参数字符串。<br>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。<br>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">s.<span class="title function_">startsWith</span>(<span class="string">&quot;world&quot;</span>, <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">endsWith</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">includes</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">6</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>使用第二个参数 n 时， endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。</p>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>返回一个新字符串，表示将原字符串重复 n 次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="title function_">repeat</span>(<span class="number">2</span>); <span class="comment">// &quot;hellohello&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><p>padStart 用于头部补全， padEnd 用于尾部补全。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;x&quot;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">&quot;ab&quot;</span>); <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&quot;x&quot;</span>.<span class="title function_">padStart</span>(<span class="number">4</span>, <span class="string">&quot;ab&quot;</span>); <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"><span class="string">&quot;x&quot;</span>.<span class="title function_">padEnd</span>(<span class="number">5</span>, <span class="string">&quot;ab&quot;</span>); <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&quot;x&quot;</span>.<span class="title function_">padEnd</span>(<span class="number">4</span>, <span class="string">&quot;ab&quot;</span>); <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure>

<p>padStart 和 padEnd 一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">  time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="第六章-数值的扩展"><a href="#第六章-数值的扩展" class="headerlink" title="第六章 数值的扩展"></a>第六章 数值的扩展</h3><p>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀 0 表示，ES6 进一步明确，要使用前缀 0o 表示。</p>
<h4 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite()"></a>Number.isFinite()</h4><p>Number.isFinite() 用来检查一个数值是否非无穷（infinity）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="title class_">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h4><p>Number.isNaN() 用来检查一个值是否为 NaN 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">15</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>它们与传统的全局方法 isFinite() 和 isNaN() 的区别在于，传统方法先调用 Number() 将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回 false 。</p>
<h4 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h4><p>ES6 将全局方法 parseInt() 和 parseFloat() ，移植到 Number 对象上面，行为完全保持不变。</p>
<h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p>Number.isInteger() 用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，整数和浮点数是同样的储存方法，所以 3 和 3.0 被视为同一个值。</p>
<h4 id="安全整数和-Number-isSafeInteger"><a href="#安全整数和-Number-isSafeInteger" class="headerlink" title="安全整数和 Number.isSafeInteger()"></a>安全整数和 Number.isSafeInteger()</h4><p>JavaScript 能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。<br>ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个<br>常量，用来表示这个范围的上下限。<br>Number.isSafeInteger() 则是用来判断一个整数是否落在这个范围之内。</p>
<h4 id="Math-对象的扩展"><a href="#Math-对象的扩展" class="headerlink" title="Math 对象的扩展"></a>Math 对象的扩展</h4><p>Math.trunc 方法用于去除一个数的小数部分，返回整数部分。<br>Math.sign 方法用来判断一个数到底是正数、负数、还是零。<br>Math.cbrt 方法用于计算一个数的立方根。<br>Math.fround 方法返回一个数的单精度浮点数形式。<br>Math.hypot 方法返回所有参数的平方和的平方根。</p>
<h3 id="第七章-函数的扩展"><a href="#第七章-函数的扩展" class="headerlink" title="第七章 函数的扩展"></a>第七章 函数的扩展</h3><p>通常情况下，定义了默认值的参数应该是函数的尾参数，</p>
<h4 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h4><p>ES6 引入 rest 参数以用于获取函数的多余参数，这样就不需要使用 arguments 对象了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>如果箭头函数不需要参数或需要多个参数，就使用圆括号代表参数部分。只有一个参数则可以不使用圆括号</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li>函数体内的 this 对象是定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以当做构造函数</li>
<li>不可以使用 arguments，super, new.target，可以使用 rest 参数代替</li>
<li>不可以使用 yield 命令</li>
</ol>
<h4 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h4><p>函数绑定运算符是并排的双冒号，双冒号左边是一个对象，右边是一个函数，该运算符会自动将左边的对象作为上下文环境(this)绑定到右边的函数上<br>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">foo::bar</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">method</span> = ::object.foo</span><br></pre></td></tr></table></figure>

<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>尾调用是指某个函数最后一步是调用另一个函数，</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">f</span>(x)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">g(x)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行尾调用优化</p>
<h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>递归非常耗费内存，因为需要同时保存成百上千个调用帧，很容易发生栈溢出错误，但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生栈溢出</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">factorial</span>(n,total)&#123;</span><br><span class="line">    if(n===1) <span class="keyword">return</span> <span class="type">total</span></span><br><span class="line">    <span class="keyword">return</span> fatorial(n-<span class="number">1</span>,n*total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title">Fibonacci</span>(n,ac1 = 1,ac2=2)&#123;</span><br><span class="line">    if(n&lt;=1)&#123;<span class="keyword">return</span> <span class="type">ac2&#125;</span></span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>,ac2,ac1+ac2)&#125;</span><br></pre></td></tr></table></figure>

<h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>将多参数的函数转换成单参数的形式</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="variable">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>,<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">function</span>(<span class="params">m</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">fn</span>.<span class="property">call</span>(<span class="variable language_">this</span>,<span class="variable">m</span>,<span class="variable">n</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">const</span> <span class="variable">tailFactorial</span> <span class="operator">=</span> <span class="title function_">currying</span>(<span class="variable">factorial</span>,<span class="number">1</span>)</span><br><span class="line"><span class="title function_">tailFactorial</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>ES6 的尾调用优化只有在严格模式下有效，正常模式下 arguments 和 caller 会跟踪函数的调用栈</p>
<p>在正常模式下可通过蹦床函数实现尾递归优化</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">trampoline</span>(f)&#123;</span><br><span class="line">    while(f &amp;&amp; f instranceof <span class="keyword">Function</span>)&#123;</span><br><span class="line">        f = f()  //只要f()执行后返回一个函数就继续执行</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>蹦床函数并不是真正的尾递归优化，下面的实现才是</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tco</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> accumulated = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">accumulator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    accumulated.<span class="built_in">push</span>(arguments);</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">      active = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (accumulated.<span class="built_in">length</span>) &#123;</span><br><span class="line">        value = f.apply(this, accumulated.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      active = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">sum</span> = tco(<span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(x + <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure>

<h3 id="第八章-数组的扩展"><a href="#第八章-数组的扩展" class="headerlink" title="第八章 数组的扩展"></a>第八章 数组的扩展</h3><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>(…) 可以将一个数组转化为逗号分隔的参数序列</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">console</span>.log(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) //<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>扩展运算符可以代替数组的 apply 方法</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Math</span>.max(...[<span class="number">14</span>,<span class="number">3</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure>

<p>可以合并数组</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[1,2]</span><span class="selector-class">.concat</span>(more)</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="selector-attr">[1,2,...more]</span></span><br></pre></td></tr></table></figure>

<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。<br>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。 Array.from 都可以将它们转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(ps).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，而这种情况扩展运算符无法转换<br>Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p>Array.of 方法用于将一组值，转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3,11,8]</span></span><br></pre></td></tr></table></figure>

<h4 id="数组实例的-copyWithin"><a href="#数组实例的-copyWithin" class="headerlink" title="数组实例的 copyWithin()"></a>数组实例的 copyWithin()</h4><p>Array.prototype.copyWithin(target, start &#x3D; 0, end &#x3D; this.length)</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h4 id="数组实例的-find-和-findIndex"><a href="#数组实例的-find-和-findIndex" class="headerlink" title="数组实例的 find()和 findIndex()"></a>数组实例的 find()和 findIndex()</h4><p>数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>

<p>数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 -1 。</p>
<h4 id="数组实例的-fill"><a href="#数组实例的-fill" class="headerlink" title="数组实例的 fill()"></a>数组实例的 fill()</h4><p>fill 方法使用给定值，填充一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].<span class="title function_">fill</span>(<span class="number">7</span>); <span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>

<h4 id="数组实例的-entries-，keys-和-values"><a href="#数组实例的-entries-，keys-和-values" class="headerlink" title="数组实例的 entries()，keys()和 values()"></a>数组实例的 entries()，keys()和 values()</h4><p>ES6 提供三个新的方法—— entries() ， keys() 和 values() ——用于遍历数组。唯一的区别是 keys() 是对键名的遍历、 values() 是对键值的遍历， entries() 是对键值对的遍历。<br>他们都返回一个遍历器对象，可用 for…of 循环遍历</p>
<h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p>该方法返回一个布尔值，标表示某个数组是否包含给定的值与字符串 includes 方法类似</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[1,2,3]</span><span class="selector-class">.includes</span>(<span class="number">2</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>相比 indexOf 方法<br>[NaN].indexOf(NaN) &#x2F;&#x2F;-1<br>[NaN].includes(NaN) &#x2F;&#x2F;true</p>
<h3 id="第九章-对象的扩展"><a href="#第九章-对象的扩展" class="headerlink" title="第九章 对象的扩展"></a>第九章 对象的扩展</h3><h4 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h4><p>ES6 允许在对象之中，只写属性名，不写属性值。这时属性值等于属性名所代表的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="comment">//等同于birth: birth</span></span><br><span class="line">  birth,</span><br><span class="line">  <span class="comment">// 等同于hello: function ()...</span></span><br><span class="line">  <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我的名字是&quot;</span>, <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>ES5 比较两个值是否相等，只有两个运算符，&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; ，前者会自动转换数据类型没后者的 NaN 不等于自身，+0 等于-0<br>Object.is()则可以避免这个问题</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(+<span class="number">0</span>,<span class="number">-0</span>) //<span class="literal">false</span></span><br><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(<span class="literal">NaN</span>,<span class="literal">NaN</span>) //<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p>Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target; <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性<br>Object.assign 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。<br>Object.assign 方法有很多用处。</p>
<ol>
<li>为对象添加属性<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x</span>, <span class="params">y</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="property">assign</span>(<span class="variable language_">this</span>, &#123;<span class="variable">x</span>, <span class="variable">y</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为对象添加方法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="title function_">someMethod</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">anotherMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>克隆对象<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">clone</span>(origin) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Object.assign(&#123;&#125;,</span> origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>合并多个对象<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const merge = <span class="function"><span class="params">(target, ...sources)</span> =&gt;</span> <span class="built_in">Object</span>.assign(target, ...sources);</span><br></pre></td></tr></table></figure></li>
<li>为属性指定默认值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEFAULTS</span> = &#123;</span><br><span class="line">    <span class="attr">logLevel</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">outputFormat</span>: <span class="string">&#x27;html&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processContent</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> options = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable constant_">DEFAULTS</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="ES6-属性的遍历-5-种方法"><a href="#ES6-属性的遍历-5-种方法" class="headerlink" title="ES6 属性的遍历 5 种方法"></a>ES6 属性的遍历 5 种方法</h5><ol>
<li>for…in 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</li>
<li>Object.keys(obj)返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。</li>
<li>Object.getOwnPropertyNames(obj)返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）。</li>
<li>Object.getOwnPropertySymbols(obj)返回一个数组，包含对象自身的所有 Symbol 属性。</li>
<li>Reflect.ownKeys(obj)返回一个数组，包含对象自身的所有属性，不管是属性名是 Symbol 或字符串，也不管是否可枚举。</li>
</ol>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p>该属性用来设置一个对象的 prototype 对象,返回参数对象本身</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span>.setPrototypeOf(<span class="type">Object</span>,prototype)</span><br></pre></td></tr></table></figure>

<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>该方法与 setPrototypeOf()方法配套，用于读取一个对象的 prototype 对象,参数如果不是对象会自动转为对象</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Rectangle()</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">const <span class="keyword">rec</span> = <span class="keyword">new</span> <span class="constructor">Rectangle()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(<span class="params">rec</span>)</span><span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">Rectangle</span>.</span></span>prototype</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>返回一个数组，成员是参数对象自身(不包含继承的)的所有可遍历属性的键名</p>
<h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h4><p>Object.values 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h4><p>Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><p>ES5 的 Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。<br>ES2017 引入了 Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。<br>该方法的引入目的，主要是为了解决 Object.assign()无法正确拷贝 get 属性和 set 属性的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target1 = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target1, source);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target1, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; value: undefined,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="第十章-Symbol"><a href="#第十章-Symbol" class="headerlink" title="第十章 Symbol"></a>第十章 Symbol</h3><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因。<br>注意，Symbol 函数前不能使用 new 命令，否则会报错。Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a.<span class="property">mySymbol</span> = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">a[mySymbol]; <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">&quot;mySymbol&quot;</span>]; <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致 a 的属性名实际上是一个字符串，而不是一个 Symbol 值。<br>Symbol 作为属性名，该属性不会出现在 for…in 、 for…of 循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。<br>Reflect.ownKeys 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&quot;my_key&quot;</span>)]: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">enum</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">nonEnum</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj); <span class="comment">// [Symbol(my_key), &#x27;enum&#x27;, &#x27;nonEnum&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h4><p>有时，我们希望重新使用同一个 Symbol 值， Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;bar&quot;</span>) === <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;bar&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Symbol</span>(<span class="string">&quot;bar&quot;</span>) === <span class="title class_">Symbol</span>(<span class="string">&quot;bar&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s1); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="第十一章-Set-和-Map-数据结构"><a href="#第十一章-Set-和-Map-数据结构" class="headerlink" title="第十一章 Set 和 Map 数据结构"></a>第十一章 Set 和 Map 数据结构</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> s.<span class="title function_">add</span>(x));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure>

<p>可用于数组去重</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="meta">[</span><span class="params">...</span><span class="literal">new</span> <span class="built_in">set</span>(<span class="built_in">array</span>)<span class="meta">]</span></span><br></pre></td></tr></table></figure>

<p>Array.from(new set(1,2,3,4)) Array.from 可以将 set 结构转为数组</p>
<h4 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h4><ol>
<li>Set.prototype.constructor ：构造函数，默认就是 Set 函数。</li>
<li>Set.prototype.size ：返回 Set 实例的成员总数。</li>
<li>add(value) ：添加某个值，返回 Set 结构本身。</li>
<li>delete(value) ：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value) ：返回一个布尔值，表示该值是否为 Set 的成员。</li>
<li>clear() ：清除所有成员，没有返回值。</li>
</ol>
<h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4><ol>
<li>keys() ：返回键名的遍历器。</li>
<li>values() ：返回键值的遍历器。</li>
<li>entries() ：返回所有成员的遍历器。</li>
<li>forEach() ：遍历 Map 的所有成员。<br>也可以直接使用 for…of 遍历 set 结构</li>
</ol>
<h4 id="Map-结构的目的和基本用法"><a href="#Map-结构的目的和基本用法" class="headerlink" title="Map 结构的目的和基本用法"></a>Map 结构的目的和基本用法</h4><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键<br>Map 原生提供三个遍历器生成函数和一个遍历方法。</p>
<ol>
<li>keys() ：返回键名的遍历器。</li>
<li>values() ：返回键值的遍历器。</li>
<li>entries() ：返回所有成员的遍历器。</li>
<li>forEach() ：遍历 Map 的所有成员。</li>
</ol>
<h3 id="第-12-章-Proxy"><a href="#第-12-章-Proxy" class="headerlink" title="第 12 章 Proxy"></a>第 12 章 Proxy</h3><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<br>Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> Proxy(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="keyword">function</span><span class="params">(target, property)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<h4 id="proxy-的实例方法"><a href="#proxy-的实例方法" class="headerlink" title="proxy 的实例方法"></a>proxy 的实例方法</h4><ul>
<li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li>
<li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li>
<li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
<li>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
<li>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>
<li>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>
<li>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ul>
<h3 id="第-13-章-Reflect"><a href="#第-13-章-Reflect" class="headerlink" title="第 13 章 Reflect"></a>第 13 章 Reflect</h3><p>Reflect 对象的设计目的有这样几个。<br>1） 将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。<br>2） 修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。<br>3） 让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name)和 Reflect.deleteProperty(obj, name)让它们变成了函数行为。<br>4）Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</p>
<h4 id="Reflect-静态方法"><a href="#Reflect-静态方法" class="headerlink" title="Reflect 静态方法"></a>Reflect 静态方法</h4><p>Reflect.apply(target, thisArg, args)<br>Reflect.construct(target, args)<br>Reflect.get(target, name, receiver)<br>Reflect.set(target, name, value, receiver)<br>Reflect.defineProperty(target, name, desc)<br>Reflect.deleteProperty(target, name)<br>Reflect.has(target, name)<br>Reflect.ownKeys(target)<br>Reflect.isExtensible(target)<br>Reflect.preventExtensions(target)<br>Reflect.getOwnPropertyDescriptor(target, name)<br>Reflect.getPrototypeOf(target)<br>Reflect.setPrototypeOf(target, prototype)</p>
<h3 id="第-14-章-Promise-对象"><a href="#第-14-章-Promise-对象" class="headerlink" title="第 14 章 Promise 对象"></a>第 14 章 Promise 对象</h3><p>Promise 是异步编程的一种解决方案，可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Primoise 新建后就会立即执行<br>Promise 实例生成以后，可以用 then 方法分别指定 Resolved 状态和 Reject 状态的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getJSON = <span class="keyword">function</span> (<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    client.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.<span class="property">onreadystatechange</span> = handler;</span><br><span class="line">    client.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.<span class="title function_">send</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">json</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Contents: &quot;</span> + json);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;出错了&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><p>then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 Resolved 时调用，第二个回调函数是 Promise 对象的状态变为 Reject 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。<br>then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><p>Promise.prototype.catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。<br>一般来说，不要在 then 方法里面定义 Reject 状态的回调函数（即 then 的第二个参数），总是使用 catch 方法。</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p>promise.all 方法将用于将多个 promise 实例包装成一个新的 promise 实例</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">const</span> p = Promise.all([<span class="built_in">p1</span>, <span class="built_in">p2</span>, <span class="built_in">p3</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>p 的状态由 p1、p2、p3 决定，分成两种情况。<br>（1）只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。<br>（2）只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">const</span> p = Promise.race([<span class="built_in">p1</span>, <span class="built_in">p2</span>, <span class="built_in">p3</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p>
<h3 id="第-15-章-lterator-和-for…of-循环"><a href="#第-15-章-lterator-和-for…of-循环" class="headerlink" title="第 15 章 lterator 和 for…of 循环"></a>第 15 章 lterator 和 for…of 循环</h3><p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费<br>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被 for…of 循环遍历<br>原生具备 Iterator 接口的数据结构如下。</p>
<p>Array<br>Map<br>Set<br>String<br>TypedArray<br>函数的 arguments 对象<br>NodeList 对象</p>
<h3 id="第-18-章-async-函数"><a href="#第-18-章-async-函数" class="headerlink" title="第 18 章 async 函数"></a>第 18 章 async 函数</h3><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便<br>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncPrint</span>(<span class="params">value, ms</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">timeout</span>(ms);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncPrint</span>(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>async 函数返回一个 Promise 对象<br>async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。<br>async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到</p>
<p>async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getTitle</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line">  <span class="keyword">return</span> html.<span class="title function_">match</span>(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getTitle</span>(<span class="string">&#x27;https://tc39.github.io/ecma262/&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// &quot;ECMAScript 2017 Language Specification&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被 reject</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure>

<p>防止出错的方法，也是将其放在 try…catch 代码块之中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">await</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h4><p>第一点，前面已经说过，await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>()</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二点，多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()]);</span><br></pre></td></tr></table></figure>

<p>第三点，await 命令只能用在 async 函数之中，如果用在普通函数，就会报错</p>
<h3 id="第-19-章-Class-基本语法"><a href="#第-19-章-Class-基本语法" class="headerlink" title="第 19 章 Class 基本语法"></a>第 19 章 Class 基本语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5 的构造函数 Point ，对应 ES6 的 Point 类的构造方法。<br>由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。 Object.assign 方法可以很方便地一次向类添加多个方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">toValue</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<h4 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h4><p>constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。constructor 方法默认返回实例对象（即 this ），完全可以指定返回另外一个<br>对象。</p>
<h4 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h4><p>类的方法内部如果含有 this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="title function_">printName</span>(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">print</span>(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">print</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line"><span class="title function_">printName</span>(); <span class="comment">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，printName 方法中的 this，默认指向 Logger 类的实例。但是，如果将这个方法提取出来单独使用，this 会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是 undefined），从而导致找不到 print 方法而报错<br>解决办法<br>在构造方法中绑定 this</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种解决方法是使用箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">printName</span> = <span class="function">(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">print</span>(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种解决方法是使用 Proxy，获取方法的时候，自动绑定 this</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">selfish</span> <span class="params">(<span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> WeakMap();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">handler</span> = &#123;</span><br><span class="line">    get (<span class="keyword">target</span>, key) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = Reflect.get(<span class="keyword">target</span>, key);</span><br><span class="line">      <span class="keyword">if</span> (typeof value !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(<span class="keyword">target</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">return</span> cache.<span class="title">get</span><span class="params">(value)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> Proxy(<span class="keyword">target</span>, <span class="keyword">handler</span>);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> Logger());</span><br></pre></td></tr></table></figure>

<h4 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h4><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  static <span class="keyword">class</span><span class="constructor">Method()</span> &#123;</span><br><span class="line">    return &#x27;hello&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Foo</span>.</span></span><span class="keyword">class</span><span class="constructor">Method()</span> <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line">var foo = <span class="keyword">new</span> <span class="constructor">Foo()</span>;</span><br><span class="line">foo.<span class="keyword">class</span><span class="constructor">Method()</span></span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>

<p>注意，如果静态方法包含 this 关键字，这个 this 指的是类，而不是实例<br>父类的静态方法，可以被子类继承。</p>
<h4 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h4><p>new 是从构造函数生成实例对象的命令。ES6 为 new 命令引入了一个 new.target 属性，该属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数。如果构造函数不是通过 new 命令或 Reflect.construct()调用的，new.target 会返回 undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-20-章-Class-的继承"><a href="#第-20-章-Class-的继承" class="headerlink" title="第 20 章 Class 的继承"></a>第 20 章 Class 的继承</h3><p>Class 之间可以通过 extends 关键字实现继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。 这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。<br>Class 不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object-getPrototypeOf-1"><a href="#Object-getPrototypeOf-1" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>Object.getPrototypeOf 方法可以用来从子类上获取父类。<br>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>super 这个关键字，有两种用法，含义不同。</p>
<ol>
<li>作为函数调用时（即 super(…args) ）， super 代表父类的构造函数。</li>
<li>作为对象调用时（即 super.prop 或 super.method() ），在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li>
</ol>
<p>ES6 规定，在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类实例。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = <span class="keyword">new</span> <span class="type">B</span>();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>如果 super 作为对象，用在静态方法之中，这时 super 将指向父类，而不是父类的原型对象,在普通方法之中指向父类的原型对象</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable">console</span>.<span class="property">log</span>(&#x27;<span class="keyword">static</span>&#x27;, <span class="variable">msg</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable">console</span>.<span class="property">log</span>(&#x27;instance&#x27;, <span class="variable">msg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="variable">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="property">myMethod</span>(<span class="variable">msg</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="property">myMethod</span>(<span class="variable">msg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property">myMethod</span>(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable">child</span> <span class="operator">=</span> <span class="variable">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable">child</span>.<span class="property">myMethod</span>(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure>

<h4 id="类的-prototype-属性和proto属性"><a href="#类的-prototype-属性和proto属性" class="headerlink" title="类的 prototype 属性和proto属性"></a>类的 prototype 属性和<strong>proto</strong>属性</h4><p>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类 prototype 属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的 prototype 属性。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">B</span>.__proto__ === <span class="type">A</span> <span class="comment">// true</span></span><br><span class="line"><span class="type">B</span>.prototype.__proto__ === <span class="type">A</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（<strong>proto</strong>属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype 属性）是父类的原型对象（prototype 属性）的实例。</p>
<h3 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h3><ol>
<li>let 取代 var</li>
<li>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</li>
<li>函数的参数如果是对象的成员，优先使用解构赋值。</li>
<li>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2 &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  <span class="attr">k1</span>: v1,</span><br><span class="line">  <span class="attr">k2</span>: v2,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>数组<br>使用扩展运算符（…）拷贝数组。<code>const itemsCopy = [...items];</code><br>使用 Array.from 方法，将类似数组的对象转为数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.foo&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> nodes = <span class="title class_">Array</span>.<span class="title function_">from</span>(foo);</span><br></pre></td></tr></table></figure></li>
<li>函数<br>立即执行函数可以写成箭头函数的形式。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Welcome to the Internet.&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
使用默认值语法设置函数参数的默认值。</li>
<li>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。</li>
</ol>
 
      <div id="toc-article">
  <div class="widget-wrap" id="toc-wrap">
    <h3 class="widget-title"><i class="fa fa-toc"></i> 文章目录</h3>
    <div class="widget">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4"><span class="toc-text">第二章 let 和 const 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#let-%E5%91%BD%E4%BB%A4"><span class="toc-text">let 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E5%91%BD%E4%BB%A4"><span class="toc-text">const 命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">第三章 变量的解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">数组的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">对象的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">函数参数的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%94%A8%E9%80%94"><span class="toc-text">变量解构赋值用途</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-text">第四章 字符串的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%81%8D%E5%8E%86%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">字符串的遍历器接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#includes-startsWith-endsWith"><span class="toc-text">includes(), startsWith(), endsWith()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repeat"><span class="toc-text">repeat()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#padStart-%EF%BC%8CpadEnd"><span class="toc-text">padStart()，padEnd()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">模板字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-text">第六章 数值的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isFinite"><span class="toc-text">Number.isFinite()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isNaN"><span class="toc-text">Number.isNaN()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-parseInt-Number-parseFloat"><span class="toc-text">Number.parseInt(), Number.parseFloat()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isInteger"><span class="toc-text">Number.isInteger()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0%E5%92%8C-Number-isSafeInteger"><span class="toc-text">安全整数和 Number.isSafeInteger()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-text">Math 对象的扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-text">第七章 函数的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rest-%E5%8F%82%E6%95%B0"><span class="toc-text">rest 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-this"><span class="toc-text">绑定 this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-text">尾调用优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-text">尾递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-text">柯里化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-text">第八章 数组的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">扩展运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-from"><span class="toc-text">Array.from()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-of"><span class="toc-text">Array.of()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-copyWithin"><span class="toc-text">数组实例的 copyWithin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-find-%E5%92%8C-findIndex"><span class="toc-text">数组实例的 find()和 findIndex()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-fill"><span class="toc-text">数组实例的 fill()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries-%EF%BC%8Ckeys-%E5%92%8C-values"><span class="toc-text">数组实例的 entries()，keys()和 values()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#includes"><span class="toc-text">includes()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-text">第九章 对象的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E6%B4%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">属性的简洁表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-is"><span class="toc-text">Object.is()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-assign"><span class="toc-text">Object.assign()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ES6-%E5%B1%9E%E6%80%A7%E7%9A%84%E9%81%8D%E5%8E%86-5-%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">ES6 属性的遍历 5 种方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-setPrototypeOf"><span class="toc-text">Object.setPrototypeOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-getPrototypeOf"><span class="toc-text">Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-keys"><span class="toc-text">Object.keys()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-values"><span class="toc-text">Object.values()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-entries"><span class="toc-text">Object.entries()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-getOwnPropertyDescriptors"><span class="toc-text">Object.getOwnPropertyDescriptors()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-Symbol"><span class="toc-text">第十章 Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol-for-%EF%BC%8CSymbol-keyFor"><span class="toc-text">Symbol.for()，Symbol.keyFor()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-Set-%E5%92%8C-Map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">第十一章 Set 和 Map 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">Set 实例的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="toc-text">遍历操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-%E7%BB%93%E6%9E%84%E7%9A%84%E7%9B%AE%E7%9A%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">Map 结构的目的和基本用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-12-%E7%AB%A0-Proxy"><span class="toc-text">第 12 章 Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#proxy-%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">proxy 的实例方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-13-%E7%AB%A0-Reflect"><span class="toc-text">第 13 章 Reflect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reflect-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">Reflect 静态方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-14-%E7%AB%A0-Promise-%E5%AF%B9%E8%B1%A1"><span class="toc-text">第 14 章 Promise 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-prototype-then"><span class="toc-text">Promise.prototype.then()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-prototype-catch"><span class="toc-text">Promise.prototype.catch()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-all"><span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-race"><span class="toc-text">Promise.race()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-15-%E7%AB%A0-lterator-%E5%92%8C-for%E2%80%A6of-%E5%BE%AA%E7%8E%AF"><span class="toc-text">第 15 章 lterator 和 for…of 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-18-%E7%AB%A0-async-%E5%87%BD%E6%95%B0"><span class="toc-text">第 18 章 async 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">使用注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-19-%E7%AB%A0-Class-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">第 19 章 Class 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constructor-%E6%96%B9%E6%B3%95"><span class="toc-text">constructor 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this-%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-text">this 的指向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class-%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">Class 的静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-target-%E5%B1%9E%E6%80%A7"><span class="toc-text">new.target 属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-20-%E7%AB%A0-Class-%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">第 20 章 Class 的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-getPrototypeOf-1"><span class="toc-text">Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">super 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84-prototype-%E5%B1%9E%E6%80%A7%E5%92%8Cproto%E5%B1%9E%E6%80%A7"><span class="toc-text">类的 prototype 属性和proto属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC"><span class="toc-text">编程风格</span></a></li></ol>
    </div>
  </div>

</div>
       
      <blockquote id="copyright">
        <p>
          原文链接:
          <a href="https://jesse121.github.io/blog/articles/2018/03/10.html"
            >https://jesse121.github.io/blog/articles/2018/03/10.html</a
          >
        </p>
        <p>版权声明: 转载请注明出处.</p>
      </blockquote>
       
    </div>
    <footer class="article-footer">
      
      <div class="article-tag-wrap">
        
 
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/javascript/" rel="tag">JavaScript</a></li></ul>
 


      </div>
        
<nav id="article-nav">
  
    <a href="/blog/articles/2018/02/11.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">older</strong>
      <div class="article-nav-title">
        
          LNMP + Apache 架构配置
        
      </div>
    </a>
  
  
    <a href="/blog/articles/2018/03/12.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">newer</strong>
      <div class="article-nav-title">
        
          CSS3创建圆圈进度条
        
      </div>
    </a>
  
</nav>
   
  <div id="comments"></div>








 
    </footer>
  </div>
</article>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> 最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/articles/2022/08/08.html">如何解决Electron应用安装在C盘没有权限更新的问题</a>
          </li>
        
          <li>
            <a href="/blog/articles/2022/08/04.html">如何用Electron+vue+vite构建桌面端应用(三)</a>
          </li>
        
          <li>
            <a href="/blog/articles/2022/08/04.html">如何用Electron+vue+vite构建桌面端应用(二)</a>
          </li>
        
          <li>
            <a href="/blog/articles/2022/07/22.html">从源码分析为什么Electron+vue项目中router不能用history模式</a>
          </li>
        
          <li>
            <a href="/blog/articles/2022/07/20.html">如何用Electron+vue+vite构建桌面端应用(一)</a>
          </li>
        
          <li>
            <a href="/blog/articles/2022/06/15.html">如何在国产银河麒麟系统Mips架构上离线安装electron</a>
          </li>
        
          <li>
            <a href="/blog/articles/2021/07/12.html">什么是SSE(Server-Sent Event)</a>
          </li>
        
          <li>
            <a href="/blog/articles/2021/06/11.html">如何用Vite快速搭建一个vue3项目</a>
          </li>
        
          <li>
            <a href="/blog/articles/2021/05/24.html">Husky配置文件没有执行权限</a>
          </li>
        
          <li>
            <a href="/blog/articles/2020/12/15.html">如何快速生成tsconfig.json文件</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签云</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/angularjs/" style="font-size: 10px;">AngularJs</a> <a href="/blog/tags/apache/" style="font-size: 12.86px;">Apache</a> <a href="/blog/tags/bootstrap/" style="font-size: 12.86px;">Bootstrap</a> <a href="/blog/tags/css/" style="font-size: 18.57px;">CSS</a> <a href="/blog/tags/centos/" style="font-size: 10px;">CentOS</a> <a href="/blog/tags/docker/" style="font-size: 12.86px;">Docker</a> <a href="/blog/tags/git/" style="font-size: 11.43px;">Git</a> <a href="/blog/tags/gitlab/" style="font-size: 10px;">Gitlab</a> <a href="/blog/tags/gulp/" style="font-size: 10px;">Gulp</a> <a href="/blog/tags/html/" style="font-size: 12.86px;">HTML</a> <a href="/blog/tags/html5/" style="font-size: 10px;">HTML5</a> <a href="/blog/tags/http/" style="font-size: 12.86px;">HTTP</a> <a href="/blog/tags/https/" style="font-size: 10px;">HTTPS</a> <a href="/blog/tags/husky/" style="font-size: 10px;">Husky</a> <a href="/blog/tags/javascript/" style="font-size: 20px;">JavaScript</a> <a href="/blog/tags/jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/blog/tags/linux/" style="font-size: 11.43px;">Linux</a> <a href="/blog/tags/mac/" style="font-size: 10px;">Mac</a> <a href="/blog/tags/mysql/" style="font-size: 12.86px;">MySQL</a> <a href="/blog/tags/nginx/" style="font-size: 11.43px;">Nginx</a> <a href="/blog/tags/node-js/" style="font-size: 11.43px;">Node.js</a> <a href="/blog/tags/php/" style="font-size: 15.71px;">PHP</a> <a href="/blog/tags/photoshop/" style="font-size: 10px;">Photoshop</a> <a href="/blog/tags/react/" style="font-size: 10px;">React</a> <a href="/blog/tags/redux/" style="font-size: 10px;">Redux</a> <a href="/blog/tags/sse/" style="font-size: 10px;">SSE</a> <a href="/blog/tags/sublimetext3/" style="font-size: 10px;">SublimeText3</a> <a href="/blog/tags/typescript/" style="font-size: 11.43px;">Typescript</a> <a href="/blog/tags/vagrant/" style="font-size: 10px;">Vagrant</a> <a href="/blog/tags/vim/" style="font-size: 10px;">Vim</a> <a href="/blog/tags/vue/" style="font-size: 10px;">Vue</a> <a href="/blog/tags/web/" style="font-size: 15.71px;">WEB</a> <a href="/blog/tags/webpack/" style="font-size: 12.86px;">Webpack</a> <a href="/blog/tags/wireshark/" style="font-size: 11.43px;">Wireshark</a> <a href="/blog/tags/yii/" style="font-size: 10px;">Yii</a> <a href="/blog/tags/electron/" style="font-size: 17.14px;">electron</a> <a href="/blog/tags/jquery/" style="font-size: 12.86px;">jQuery</a> <a href="/blog/tags/kylin/" style="font-size: 10px;">kylin</a> <a href="/blog/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/blog/tags/vite/" style="font-size: 14.29px;">vite</a> <a href="/blog/tags/vscode/" style="font-size: 10px;">vscode</a> <a href="/blog/tags/vue/" style="font-size: 10px;">vue</a> <a href="/blog/tags/vue3/" style="font-size: 12.86px;">vue3</a> <a href="/blog/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/" style="font-size: 10px;">前端监控</a> <a href="/blog/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/blog/tags/%E7%AE%97%E6%B3%95/" style="font-size: 12.86px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> 分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/bootstrap/">Bootstrap</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/electron/">Electron</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/html-css/">HTML-CSS</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/html5/">HTML5</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/javascript/">JavaScript</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/mysql/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/node-js/">Node.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/php/">PHP</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/photoshop/">Photoshop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/typescript/">Typescript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/vue/">Vue</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/web/">WEB</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/jquery/">jQuery</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/translation/">前端翻译</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">开发问题记录</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/notes/">读书笔记</a><span class="category-list-count">16</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> 归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/">2022年</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2021/">2021年</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/">2020年</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/">2019年</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/">2018年</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/">2017年</a><span class="archive-list-count">26</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/">2016年</a><span class="archive-list-count">27</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> 友情链接</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.mahaixiang.cn/internet/300.html">深入理解互联网协议的原理</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://javascript.ruanyifeng.com/">JavaScript 标准参考教程</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">Mozilla Developer Network</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/blog/sitemap.xml">网站地图</a>
        <span> | </span><a href="/blog/atom.xml">订阅本站</a>
        <span> | </span><a href="/blog/about/">联系博主</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2022 Jesse.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
  </div>
  
<script src="/blog/js/jquery-3.4.1.min.js"></script>


<script src="/blog/js/search.json.js"></script>


  
<script src="/blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/blog/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  
  


  
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: "1d84813ae13cd94072f0",
    clientSecret: "4a4dd2af0c622e983dd90f5daf15c3ebd86b8ae9",
    repo: "blog",
    owner: "jesse121",
    admin: ["jesse121"],
    id: md5(window.location.pathname),
    proxy: "https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token",
    distractionFreeMode: false,
    language: "zh-CN",
    pagerDirection: "last",
  });
  gitalk.render("comments");
</script>
         



</body>
</html>